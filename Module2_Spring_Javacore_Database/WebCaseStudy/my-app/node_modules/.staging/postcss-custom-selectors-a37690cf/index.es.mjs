import parser from 'postcss-selector-parser';
import fs from 'fs';
import path from 'path';
import postcss from 'postcss';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/* Return a Selectors AST from a Selectors String
/* ========================================================================== */

var getSelectorsAstFromSelectorsString = (selectorString => {
  let selectorAST;
  parser(selectors => {
    selectorAST = selectors;
  }).processSync(selectorString);
  return selectorAST;
});

var getCustomSelectors = ((root, opts) => {
  // initialize custom selectors
  const customSelectors = {}; // for each custom selector atrule that is a child of the css root

  root.nodes.slice().forEach(node => {
    if (isCustomSelector(node)) {
      // extract the name and selectors from the params of the custom selector
      const _node$params$match = node.params.match(customSelectorParamsRegExp),
            _node$params$match2 = _slicedToArray(_node$params$match, 3),
            name = _node$params$match2[1],
            selectors = _node$params$match2[2]; // write the parsed selectors to the custom selector


      customSelectors[name] = getSelectorsAstFromSelectorsString(selectors); // conditionally remove the custom selector atrule

      if (!Object(opts).preserve) {
        node.remove();
      }
    }
  });
  return customSelectors;
}); // match the custom selector name

const customSelectorNameRegExp = /^custom-selector$/i; // match the custom selector params

const customSelectorParamsRegExp = /^(:--[A-z][\w-]*)\s+([\W\w]+)\s*$/; // whether the atrule is a custom selector

const isCustomSelector = node => node.type === 'atrule' && customSelectorNameRegExp.test(node.name) && customSelectorParamsRegExp.test(node.params);

// return transformed selectors, replacing custom pseudo selectors with custom selectors
function transformSelectorList(selectorList, customSelectors) {
  let index = selectorList.nodes.length - 1;

  while (index >= 0) {
    const transformedSelectors = transformSelector(selectorList.nodes[index], customSelectors);

    if (transformedSelectors.length) {
      selectorList.nodes.splice(index, 1, ...transformedSelectors);
    }

    --index;
  }

  return selectorList;
} // return custom pseudo selectors replaced with custom selectors

function transformSelector(selector, customSelectors) {
  const transpiledSelectors = [];

  for (const index in selector.nodes) {
    const _selector$nodes$index = selector.nodes[index],
          value = _selector$nodes$index.value,
          nodes = _selector$nodes$index.nodes;

    if (value in customSelectors) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = customSelectors[value].nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          const replacementSelector = _step.value;
          const selectorClone = selector.clone();
          selectorClone.nodes.splice(index, 1, ...replacementSelector.clone().nodes.map(node => {
            // use spacing from the current usage
            node.spaces = _objectSpread({}, selector.nodes[index].spaces);
            return node;
          }));
          const retranspiledSelectors = transformSelector(selectorClone, customSelectors);
          adjustNodesBySelectorEnds(selectorClone.nodes, Number(index));

          if (retranspiledSelectors.length) {
            transpiledSelectors.push(...retranspiledSelectors);
          } else {
            transpiledSelectors.push(selectorClone);
          }
        }
      } catch (err) {
        _didIteratorError = tru